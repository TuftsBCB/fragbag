#!/usr/bin/env python2.7

try:
    from cStringIO import StringIO
except ImportError:
    from StringIO import StringIO
from collections import defaultdict
import csv
import os.path as path
import random

import numpy as np

import pybcb as bcb
import pybcb.flags as flags

flags.use_all('frag-lib', 'cpu', 'tmp-dir', 'results-dir',
              'ignore-cache', 'no-cache')
flags.use('structure', (
    lambda: flags.add('--structure', action='store_true',
                      help='When set, structure is used instead of sequence. '
                           'If this is set, then a structural fragment '
                           'library must be provided.'),
    None,
))
flags.use('dists', (
    lambda: flags.add('--dists', type=str,
                      default='/data/bio/mattbench/astral.gob',
                      help='The mattbench alignment distances. May be '
                           'alignment out directory from Matt or a cached '
                           'GOB encoded file generated by mattbench-cluster.'),
    flags.verify_path,
))
flags.use('tree', (
    lambda: flags.add('--tree', type=str,
                      default='/data/bio/mattbench/dendrogram.tree',
                      help='The dendrogram in Newick tree format.'),
    flags.verify_path,
))
flags.use('scop', (
    lambda: flags.add('--scop', type=str,
                      default='/data/bio/scop/fasta',
                      help='A directory to either SCOP fasta or PDB files.'),
    flags.verify_path,
))
flags.use('threshold', (
    lambda: flags.add('--threshold', type=float, default=0.097702,
                      help='The mattbench alignment distance threshold.'),
    None,
))
flags.use('iters', (
    lambda: flags.add('--iters', type=int, default=5,
                      help='The number of iterations to run the experiment.'),
    None,
))
flags.use('neighbors', (
    lambda: flags.add('--neighbors', type=int, default=10,
                      help='The number of neighbors to search for closest.'),
    None,
))
flags.init()

bcb.set_exp_dir(flags.config.tmp_dir)
bcb.set_results_dir(flags.config.results_dir)
bcb.make()

flib_name = path.basename(flags.config.frag_lib)
flib_kind = 'structure' if flags.config.structure else 'sequence'
outdir = bcb.rjoin('%s-%f' % (flib_kind, flags.config.threshold))
bcb.makedirs(outdir)

def scop_path(scop_id):
    scop = flags.config.scop
    if flags.config.structure:
        return path.join(scop, scop_id[2:4], '%s.ent' % scop_id)
    else:
        return path.join(scop, '%s.fasta' % scop_id)

# Outline of experiment:
#
# 1. Cut the mattbench tree at the threshold specified and store the clusters
#    in a tmp directory (csv file).
#
# 2. Repeat {iters} times:
#      Select 2 random proteins from each cluster with 2 or more proteins.
#      For each protein, find the nearest neighbor in Fragbag space.
#      Correct if and only if neighbor matches protein in same cluster.
#
# 3. Report mean and total accuracy.

# (1)
fclusters = bcb.ejoin('%f.csv' % flags.config.threshold)
bcb.cached_cmd([fclusters],
               'mattbench-cluster', '-threshold', str(flags.config.threshold),
               flags.config.dists, flags.config.tree, fclusters)

# (2)
clusters = []
for row in csv.reader(open(fclusters)):
    cluster = filter(lambda d: bcb.readable(scop_path(d)), row)
    if len(cluster) > 1:
        clusters.append(row)
# clusters = random.sample(clusters, len(clusters)) 

stats = []
for i in xrange(flags.config.iters):
    twins = {}
    for c in clusters:
        d1, d2 = random.sample(c, 2)
        twins[d1] = d2
        twins[d2] = d1

    cmdargs = map(scop_path, twins.keys())
    out = StringIO(bcb.cmd('flib', 'pairdist', '-quiet',
                           flags.config.frag_lib, *cmdargs))
    dists = defaultdict(list)
    for row in csv.reader(out, delimiter='\t'):
        d1, d2, dist = row[0], row[1], float(row[2])
        dists[d1].append((dist, d2))
        dists[d2].append((dist, d1))

    total, correct = 0, 0
    for d, twin in twins.items():
        total += 1

        neighbors = [n for _, n in sorted(dists[d])]
        ubound = min(len(neighbors), flags.config.neighbors)
        if twin in neighbors[0:ubound]:
            correct += 1
    stats.append({'correct': correct, 'total': total})

# (3)
def acc(stat):
    return 100 * float(stat['correct']) / float(stat['total'])
outname = '%s_iters%d_neighbors%d' \
          % (flib_name, flags.config.iters, flags.config.neighbors)
out = path.join(outdir, outname)

totaled = {'correct': 0, 'total': 0}
for stat in stats:
    totaled['correct'] += stat['correct']
    totaled['total'] += stat['total']

print out
outf = open(out, 'w+')
print >> outf, 'Clusters: %d' % len(clusters)
print >> outf, 'Mean accuracy:  %f' % np.mean(map(acc, stats))
print >> outf, 'Total accuracy: %f (%d/%d)' \
               % (acc(totaled), totaled['correct'], totaled['total'])
outf.close()

